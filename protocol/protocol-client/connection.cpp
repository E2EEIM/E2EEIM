#include "connection.h"
#include "encryption.h"
#include <QFile>

Connection::Connection(QObject *parent) : QObject(parent){

    //Begin setup of GPGME
    gpgme_check_version (NULL);
    setlocale (LC_ALL, "");
    gpgme_set_locale (NULL, LC_CTYPE, setlocale (LC_CTYPE, NULL));
//#ifndef HAVE_W32_SYSTEM
//    gpgme_set_locale (NULL, LC_MESSAGES, setlocale (LC_MESSAGES, NULL));
//#endif
    //err = gpgme_engine_check_version (GPGME_PROTOCOL_OpenPGP);
    //detectError(err);
    //End setup of GPGME

    // Create the GPGME Context
    err = gpgme_new (&ctx);
    // Error handling
    detectError(err);

    // Set the context to textmode
    gpgme_set_textmode (ctx, 1);
    // Enable ASCII armor on the context
    gpgme_set_armor (ctx, 1);

    const char *servKey= "TEST CLIENT_PROTOCOL";

    err = gpgme_op_keylist_start(ctx,servKey, 1);
    detectError(err);

    int nKeysFound=0;

    while (!(err = gpgme_op_keylist_next(ctx, &key))) { // loop through the keys in the keyring
        activeUserKey=key;
        nKeysFound++;
    }



    if(nKeysFound == 0){
        const char *parms = "<GnupgKeyParms format=\"internal\">\n"
            "Key-Type: RSA\n"
            "Key-Length: 4096\n"
            "Subkey-Type: RSA\n"
            "Subkey-Length: 4096\n"
            "Name-Real: TEST CLIENT_PROTOCOL\n"
            "Name-Comment: (Generated by E2EEIM Chat, Passphrase:client)\n"
            "Name-Email: client@e2eeim.chat\n"
            "Expire-Date: 1d\n"
            "Passphrase: client\n"
            "</GnupgKeyParms>\n";

        gpgme_genkey_result_t GenKeyresult;
        GenKeyresult = genKey(ctx, err, parms);
        qDebug() << "\n--------Finished Key Generation----------";
        err = gpgme_get_key(ctx,GenKeyresult->fpr,&key,1);
        detectError(err);
        activeUserKey = key;

        qDebug() << "Active User's key is...";
        printKeys(activeUserKey);

        const char *activeUserPubKeyFile="activeUserPubKey.key";

        exportKey(ctx, activeUserKey, err, activeUserPubKeyFile);
        qDebug() << "'activeUserPubKey.key' Saved in current directory\n\n";
    }
    else{
        qDebug() << "\n-------FOUND USEABLE PGP KEY-------------";
        qDebug() << "Active User's key is...";
        printKeys(activeUserKey);

        const char *activeUserPubKeyFile="activeUserPubKey.key";

        exportKey(ctx, activeUserKey, err, activeUserPubKeyFile);
        qDebug() << "'activeUserPubKey.key' Saved in current directory\n\n";
    }

    QFile f("activeUserPubKey.key");
    f.open(QFile::ReadOnly | QFile::Text);

    QTextStream in(&f);
    QString infile;
    infile+=in.readAll();
    f.flush();
    f.close();

    const QString tmp=infile;
    activeUserPubKey.append(tmp);

}

QByteArray Connection::getActiveUserPubKey(){
    return activeUserPubKey;
}

void Connection::letConnect(){

    socket = new QTcpSocket(this);

    socket->connectToHost("127.0.0.1",2222);
    qDebug() << "Waiting for connection";
    if(socket->waitForConnected(3000)){
        qDebug() << "Connected!";
        //socket->close();
    }
    else{
        qDebug() << "Not Connected!";
    }

    connect(socket, SIGNAL(readyRead()), this, SLOT(readyRead()),Qt::DirectConnection);
    connect(this,SIGNAL(newDataArrived(QByteArray)), this, SLOT(dataFilter(QByteArray)));
}

QString Connection::getActiveUserName(){
    char *activeU=activeUserKey->uids->name;
    QString activeUserName(activeU);
    return activeUserName;
}

QByteArray Connection::encryptToServ(QByteArray data, const char *outFileName){

    QByteArray encrypted;
    QFile File("temp.data");
    if(!File.open(QFile::WriteOnly | QFile::Text)){
        qDebug() << "cound not open file for writing";
        abort();
    }
    QTextStream out(&File);
    out << data;
    File.flush();
    File.close();

    gpgme_signers_add(ctx, activeUserKey);
    encryptSign(ctx, err, ServerKey, "temp.data", outFileName);

    QFile outFile(outFileName);

    if(!outFile.open(QFile::ReadOnly | QFile::Text)){
        qDebug() << "cound not open file for writing";
        abort();
    }
    QTextStream in(&outFile);
    QString ciper;
    ciper=in.readAll();
    outFile.flush();
    outFile.close();

    encrypted.append(ciper);

    return encrypted;

}


void Connection::dataFilter(QByteArray data){

    bool ok;
    QString dataQString(data);


    if(dataQString.mid(8,1).data()->unicode()==2){
        qDebug() << "*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2";
        qDebug() << "<-*2 RECIEVED Server's Public key";
        printf("+--------------------+-------------+----------------------------------+\n");
        printf("| data size (8byte)  | op (1 byte) |    payload (server public key)   |\n");
        printf("+--------------------+-------------+----------------------------------+\n");

        updateServPubKey(data);

    }
    else if(dataQString.mid(8,1).data()->unicode()==4){
        qDebug() << "*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4";
        qDebug() << "<-*4 RECIEVED Sign up result";
        printf("+--------------------+-------------+----------------------------------+\n");
        printf("| data size (8byte)  | op (1 byte) |    encrypted(result message)     |\n");
        printf("+--------------------+-------------+----------------------------------+\n");
    }

    qDebug() << "       Byte Array:" << "[remove next line's //(comment) to see byte array value]";
    //qDebug() << "     Byte Array:" << data;

    qDebug() << "  Total data size:" << data.size();

    qDebug() << "data size in byte:"<< dataQString.mid(0,8);
    qDebug() << " data size in int:"<< dataQString.mid(0,8).toInt(&ok, 16);

    qDebug() << "operation in byte:"<< dataQString.mid(8,1).data()->toLatin1();
    qDebug() << " operation in int:"<< dataQString.mid(8,1).data()->unicode();

    qDebug() << "     payload size:"<< dataQString.mid(9).size();
    qDebug() << "    payload value:"<< "[Remove next line's //(comment) to see payload value]";
    //qDebug() << "    payload value:"<< dataQString.mid(9);
    qDebug() << "\n\n\n\n\n";


}

void Connection::updateServPubKey(QByteArray data){

    QFile File("servPubKey.key");
    if(!File.exists()){
            if(!File.open(QFile::WriteOnly | QFile::Text)){
                qDebug() << "cound not open file for writing";
                abort();
            }
            QTextStream out(&File);
            out << data.mid(9);
            File.flush();
            File.close();
            qDebug() << "Server public key saved to servPubKey.key in current directory.";
    }
    else{
        if(!File.open(QFile::ReadOnly | QFile::Text)){
            qDebug() << "cound not open file for writing";
            abort();
        }
        QTextStream in(&File);
        QString oldServPubKey;
        oldServPubKey=in.readAll();
        File.flush();
        File.close();

        //compare old and new servPubKey
        QByteArray oldPubkey;
        oldPubkey.append(oldServPubKey);
        if(oldPubkey==data.mid(9)){
            qDebug() << "Server Public Key already UP-To-DATE";
        }
        else{

            if(!File.open(QFile::WriteOnly | QFile::Text)){
                qDebug() << "cound not open file for writing";
                abort();
            }
            QTextStream out(&File);
            out << data.mid(9);
            File.flush();
            File.close();
            qDebug() << "Server public key UPDATED!";
        }
    }
    gpgme_import_result_t importKeyResult = importKey(ctx, err, "servPubKey.key");
    qDebug() << "importKeyResult.import:" << importKeyResult->imported;
    qDebug() << "importKeyResult.unchange:" << importKeyResult->unchanged;

    const char *servKey= "E2EEIM SERVER";

    err = gpgme_op_keylist_start(ctx,servKey, 1);
    detectError(err);

    int nKeysFound=0;

    while (!(err = gpgme_op_keylist_next(ctx, &key))) { // loop through the keys in the keyring
        ServerKey=key;
        nKeysFound++;
    }
    if(nKeysFound==0){
        qDebug()<<"SERVER KEY NOT FOUND!!!!";

    }
}

void Connection::send(QByteArray data){
    QByteArray package=data;

    bool ok;
    QString dataQString(data);


    if(dataQString.mid(8,1).data()->unicode()==1){
        qDebug() << "*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1";
        qDebug() << "*1-> SEND Require connection";
        printf("+----------------------------------+----------------------+\n");
        printf("|        data Size (8 byte)        |  Operation (2 byte)  |\n");
        printf("+----------------------------------+----------------------+\n");
    }
    else if(dataQString.mid(8,1).data()->unicode()==3){
        qDebug() << "*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3";
        qDebug() << "*3-> SEND sign up request\n";
        printf("                 1 byte            8 byte           <128      ~4000\n");
        printf("          +------------------+------------------+----------+-----------+\n");
        printf("payload = |  Username Length | UsrPubKey Length | Username | UsrPubKey |\n");
        printf("          +------------------+------------------+----------+-----------+\n");
        printf("\n");
        printf("+---------------------+-------------+----------------------------------+\n");
        printf("|  data Size (8 byte) | OP (1 byte) |          encrypted(payload)      |\n");
        printf("+---------------------+-------------+----------------------------------+\n");

    }


    qDebug() << "       Byte Array: " << "[remove next line's //(comment) to see byte array value]";
    //qDebug() << "     Byte Array:" << data;

    qDebug() << "  Total data size:" << data.size();

    qDebug() << "data size in byte:"<< dataQString.mid(0,8);
    qDebug() << " data size in int:"<< dataQString.mid(0,8).toInt(&ok, 16);

    qDebug() << "operation in byte:"<< dataQString.mid(8,1).data()->toLatin1();
    qDebug() << " operation in int:"<< dataQString.mid(8,1).data()->unicode();

    qDebug() << "     payload size:"<< dataQString.mid(9).size();
    qDebug() << "    payload value:"<< "[Remove next line's //(comment) to see payload value]";
    //qDebug() << "    payload value:"<< dataQString.mid(9);
    qDebug() << "\n\n\n\n\n";

    socket->write(package);
    socket->flush();
    socket->waitForBytesWritten((1000));


    int op=dataQString.mid(8,1).data()->unicode();
    if(op==1 || op==3){
        socket->waitForReadyRead(); //wait 30s
    }

    //letDisconnect();

    /*
    socket->waitForReadyRead(3000);
    qDebug() << "Reading:" << socket->bytesAvailable();

    QByteArray returnFromServ= socket->readAll();
    QString servRe=QString::fromUtf8(returnFromServ);
    //qDebug() << servRe;


    qDebug() << "*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2";
    qDebug() << "Received data from server";
    printf("+---------------------------------------------------------+\n");
    printf("| public key size (8byte) | payload (server public key)   |\n");
    printf("+---------------------------------------------------------+\n");
    qDebug() << "Package size="<< servRe.size() <<"Byte";
    qDebug() << "Header size = 8 Byte";
    qDebug() << "Payload size=" << servRe.size()-8 <<"Byte";


    bool ok;
    if((returnFromServ.left(8)).toInt(&ok, 16)==
            returnFromServ.remove(0, 8).size()){

        qDebug() << "received all data ="<< "TRUE";
    }
    else{
        qDebug() << "received all data ="<< "FALSE";
    }

    qDebug() << "\n\n\n\n\n";

    data.clear();
    QByteArray ActiveUserName = activeUserKey->uids->name;
    qDebug() << "ActiveUserName=" << ActiveUserName;
    qDebug() << "ActiveUserName_length=" <<ActiveUserName.length();
    qDebug() << "ActiveUserPubKey_size="<< activeUserPubKey.size();


    //QByteArray

    //data.append(activeUserPubKey);
    //qDebug() << activeUserPubKey.size();
    //QByteArray keysize = activeUserPubKey.toHex();
    //data.append(keysize);

    //qDebug() << data;
    //socket->write(data);
    */

}

void Connection::readyRead(){

    QByteArray data = socket->readAll();
    qDebug() <<"Received data from server!";
    bool ok;
    QString dataQString(data);
    int dataSize=dataQString.mid(0,8).toInt(&ok, 16);
    int payloadAndOp=dataQString.mid(8).length();

    if(payloadAndOp==dataSize){
       qDebug() <<"(data SIZE == PAYLOAD + OP) -> NO LOSS!";
       emit newDataArrived(data);
    }


}

void Connection::letDisconnect(){
    socket->close();
}
