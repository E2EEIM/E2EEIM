#include "mythread.h"
#include "encryption.h"
#include <QFile>
#include <QString>
#include <QHostAddress>

MyThread::MyThread(QQueue<QByteArray> *queue, QList<QString> *usernameList,
                   QList<QString> *userKeyList, int ID, QObject *parent) :
    QThread(parent)
{

    queuePtr=queue;
    this->usernameList=usernameList;
    this->userKeyList=userKeyList;

    this->socketDescriptor = ID;

    //Begin setup of GPGME
    gpgme_check_version (NULL);
    setlocale (LC_ALL, "");
    gpgme_set_locale (NULL, LC_CTYPE, setlocale (LC_CTYPE, NULL));
//#ifndef HAVE_W32_SYSTEM
//    gpgme_set_locale (NULL, LC_MESSAGES, setlocale (LC_MESSAGES, NULL));
//#endif
    //err = gpgme_engine_check_version (GPGME_PROTOCOL_OpenPGP);
    //detectError(err);
    //End setup of GPGME

    // Create the GPGME Context
    err = gpgme_new (&ctx);
    // Error handling
    detectError(err);

    // Set the context to textmode
    gpgme_set_textmode (ctx, 1);
    // Enable ASCII armor on the context
    gpgme_set_armor (ctx, 1);



    const char *servKey= "E2EEIM SERVER";

    err = gpgme_op_keylist_start(ctx,servKey, 1);
    detectError(err);

    int nKeysFound=0;

    while (!(err = gpgme_op_keylist_next(ctx, &key))) { // loop through the keys in the keyring
        ServerKey=key;
        nKeysFound++;
    }

    if(nKeysFound == 0){
        const char *parms = "<GnupgKeyParms format=\"internal\">\n"
            "Key-Type: RSA\n"
            "Key-Length: 4096\n"
            "Subkey-Type: RSA\n"
            "Subkey-Length: 4096\n"
            "Name-Real: E2EEIM SERVER\n"
            "Name-Comment: (Generated by E2EEIM Chat, Passphrase:abcdefgh)\n"
            "Name-Email: server@e2eeim.chat\n"
            "Expire-Date: 1d\n"
            "Passphrase: abcdefgh\n"
            "</GnupgKeyParms>\n";

        gpgme_genkey_result_t GenKeyresult;
        GenKeyresult = genKey(ctx, err, parms);
        qDebug() << "\n--------Finished Key Generation----------";
        err = gpgme_get_key(ctx,GenKeyresult->fpr,&key,1);
        detectError(err);
        ServerKey = key;

        qDebug() << "SERVER KEY IS...";
        printKeys(ServerKey);

        const char *serverPubKeyFile="serverPubKey.key";

        exportKey(ctx, ServerKey, err, serverPubKeyFile);
        qDebug() << "'serverPubKey.key' Saved in current directory\n\n";
    }
    else{
        qDebug() << "\n-------FOUND USEABLE SERVER KEY----------";
        qDebug() << "SERVER KEY IS...";
        printKeys(ServerKey);

        const char *serverPubKeyFile="serverPubKey.key";

        exportKey(ctx, ServerKey, err, serverPubKeyFile);
        qDebug() << "'serverPubKey.key' Saved in current directory\n\n";
    }

    QFile f("serverPubKey.key");
    f.open(QFile::ReadOnly | QFile::Text);

    QTextStream in(&f);
    QString infile;
    infile+=in.readAll();
    f.flush();
    f.close();

    const QString tmp=infile;
    serverPubKey.append(tmp);

}

void MyThread::run(){

    //Thread starts here.
    qDebug() <<"sockfd No." << socketDescriptor << " Starting thread";

    socket = new QTcpSocket();
    if(!socket->setSocketDescriptor(this->socketDescriptor)){

        emit error(socket->error());
        return;
    }

    qDebug() << "Client peerAddress:"<< socket->peerAddress().toString();
    qDebug() << "Client peerPort:"<< socket->peerPort();


    connect(socket,SIGNAL(readyRead()), this, SLOT(readyRead()),Qt::DirectConnection);
    connect(socket,SIGNAL(disconnected()), this, SLOT(disconnected()),Qt::DirectConnection);

    qDebug() << "Client connected to sockfd No." << socketDescriptor;

    exec();
}

void MyThread::dataFilter(QByteArray data){

    //QString dataQString(data);
    int intOp=QString(data.mid(4,1)).data()->unicode();
    qDebug() << "intOp:"<< intOp;


    if(intOp==1){
        qDebug() << "*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1*1";
        qDebug() << "*1-> RECEIVED Client require connection";
        printf("+----------------------+----------------------+-----------------+\n");
        printf("|  data Size (4 byte)  |  Operation (1 byte)  |Payload (0 byte) |\n");
        printf("+----------------------+----------------------+-----------------+\n");

        printDataDetail(data);
        qDebug() << "\n\n\n\n\n";

        //Create <-*2 package for reply
        data.clear();

          //-Append server's public key to Byte Array
        data.append(serverPubKey);

          //-Insert operation to index 0
        data.insert(0,(char)2);

          //-Insert size of (operation + payload) to index 0
        int payloadAndOpSize=serverPubKey.size()+1;
        QByteArray dataSize;
        QDataStream ds(&dataSize, QIODevice::WriteOnly);
        ds << payloadAndOpSize;
        data.insert(0, dataSize);

        send(data);

    }
    if(intOp==3){
        qDebug() << "*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3";
        qDebug() << "*3-> RECEIVED Client sign up request\n";
        printf("                 1 byte            4 byte           <255      ~4000\n");
        printf("          +------------------+------------------+----------+-----------+\n");
        printf("payload = |  Username Length | UsrPubKey Length | Username | UsrPubKey |\n");
        printf("          +------------------+------------------+----------+-----------+\n");
        printf("\n");
        printf("+---------------------+-------------+----------------------------------+\n");
        printf("|  data Size (4 byte) | OP (1 byte) |          encrypted(payload)      |\n");
        printf("+---------------------+-------------+----------------------------------+\n");

        printDataDetail(data);

        //decrypt data to get payload
        QByteArray payload=decryptData(data, "signUp.pgp");

        qDebug() << "\n-DECRYPTED PAYLOAD-";
        int usernameLength=QString(payload).mid(0,1).data()->unicode();

        QString username(payload.mid(5, usernameLength));

        int userPublicKeyLength;
        QDataStream ds(payload.mid(1,4));
        ds >> userPublicKeyLength;

        qDebug() << "Username length:"<< usernameLength;
        qDebug() << "Username:" << username;
        qDebug() << "User's public key Length:" << userPublicKeyLength;
        qDebug() << "User's public key:"<< "[remove next line's //(comment) to see user's public key]";
        //qDebug() << "User's public key:"<< payload.mid(5+usernameLength);



        qDebug() << "\n!!!!! ASSUME USERNAME AVAILABLE FOR SIGN UP !!!!!";


        qDebug() << "\n-ADD NEW USER TO LIST-";
        addNewUser(payload);
        qDebug() << "Username:"<< username;
        qDebug() << "User's KeyID:" << userKeyList->at(usernameList->indexOf(username));

        qDebug() << "\n\n\n\n\n";


        //Send sign up result

        //Create <-*4 sign up result
        data.clear();
        QString result="Sign up success, "+username+" ready for sign in!";
        QByteArray signUpResult;
        signUpResult.append(result);
        QString userSubkey=userKeyList->at(usernameList->indexOf(username));

        qDebug() << "-SIGN UP RESULT ENCRYPTING-";
        QByteArray ciper=encryptToClient(signUpResult, userSubkey, "signUpResult.ciper");

        //-Append server's encrypted sign up result message to Byte Array
        data.append(ciper);

        //-Insert operation to index 0
        data.insert(0,(char)4);

        //-Insert size of (operation + payload) to index 0
        int payloadAndOpSize=serverPubKey.size()+1;
        QByteArray dataSize;
        QDataStream ds2(&dataSize, QIODevice::WriteOnly);
        ds2 << payloadAndOpSize;
        data.insert(0, dataSize);

        send(data);

    }

}


void MyThread::printDataDetail(QByteArray data){

    QDataStream ds(data.mid(0,4));
    int dataSize;
    ds >> dataSize;

    qDebug() << "       Byte Array:" << "[remove next line's //(comment) to see byte array value]";
    //qDebug() << "     Byte Array:" << data;
    qDebug() << "  Total data size:" << data.size();
    qDebug() << "data size in byte:"<< data.mid(0,4);
    qDebug() << " data size in int:"<< dataSize;
    qDebug() << "operation in byte:"<< data.mid(4,1);
    qDebug() << " operation in int:"<< QString(data.mid(4,1)).data()->unicode();
    qDebug() << "     payload size:"<< data.mid(5).size();
    qDebug() << "    payload value:"<< "[Remove next line's //(comment) to see payload value]";
    //qDebug() << "    payload value:"<< dataQString.mid(5);

}

QByteArray MyThread::decryptData(QByteArray data, const char* outputFileName){

    QByteArray decrypted;
    QByteArray ciper=data.mid(5);

    QFile File("temp.data");
    if(!File.open(QFile::WriteOnly | QFile::Text)){
        qDebug() << "cound not open file for writing";
        abort();
    }
    QTextStream out(&File);
    out << ciper;
    File.flush();
    File.close();

    decrypt(ctx, err, "temp.data", outputFileName);

    QFile outFile(outputFileName);

    if(!outFile.open(QFile::ReadOnly | QFile::Text)){
        qDebug() << "cound not open file for writing";
        abort();
    }
    QTextStream in(&outFile);
    QString dataStream;
    dataStream=in.readAll();
    outFile.flush();
    outFile.close();

    decrypted.append(dataStream);

    return decrypted;
}


void MyThread::addNewUser(QByteArray payload){

    int usernameLength=QString(payload).mid(0,1).data()->unicode();
    QString username(payload.mid(5, usernameLength));

    // Import user's public key
    QByteArray publicKey=payload.mid(5+usernameLength);

    QFile File("temp.data");
    if(!File.open(QFile::WriteOnly | QFile::Text)){
        qDebug() << "cound not open file for writing";
        abort();
    }
    QTextStream out(&File);
    out << publicKey;
    File.flush();
    File.close();

    gpgme_import_result_t importKeyResult = importKey(ctx, err, "temp.data");
    qDebug() <<"Import key, condered:"<< importKeyResult->considered;
    qDebug() <<"Import key, imported:"<< importKeyResult->imported;
    qDebug() <<"Import key, unchaged:"<< importKeyResult->unchanged;

    //Get user's keyID
    gpgme_key_t userKey=getKey(username);
    QString userKeyID(userKey->subkeys->keyid);

    usernameList->append(username);
    userKeyList->append(userKeyID);
}

gpgme_key_t MyThread::getKey(QString pattern){

    gpgme_key_t targetKey;
    QByteArray ba = pattern.toLatin1();
    const char *patt=ba.data();
    err = gpgme_op_keylist_start(ctx, patt, 0);
    detectError(err);
    int nKeysFound=0;
    while (!(err = gpgme_op_keylist_next(ctx, &key))) { // loop through the keys in the keyring
        targetKey=key;
        nKeysFound++;
    }

    if(nKeysFound==0){
        qDebug() << "nKeyFound:" << nKeysFound;
        abort();
    }
    return targetKey;
}

QByteArray MyThread::encryptToClient(QByteArray data, QString recipient, const char *outFileName){

    gpgme_key_t recipientKey=getKey(recipient);
    QByteArray encrypted;
    QFile File("temp.data");
    if(!File.open(QFile::WriteOnly | QFile::Text)){
        qDebug() << "cound not open file for writing";
        abort();
    }
    QTextStream out(&File);
    out << data;
    File.flush();
    File.close();

    qDebug() << "Signer's key...";
    printKeys(ServerKey);
    qDebug() << "Recipient's key...";
    printKeys(recipientKey);

    gpgme_signers_add(ctx, ServerKey);
    encryptSign(ctx, err, recipientKey, "temp.data", outFileName);
    gpgme_key_unref (recipientKey);

    QFile outFile(outFileName);

    if(!outFile.open(QFile::ReadOnly | QFile::Text)){
        qDebug() << "cound not open file for writing";
        abort();
    }
    QTextStream in(&outFile);
    QString ciper;
    ciper=in.readAll();
    outFile.flush();
    outFile.close();

    encrypted.append(ciper);

    return encrypted;

}


void MyThread::send(QByteArray data){

    socket->write(data);
    socket->flush();
    socket->waitForBytesWritten(1000);

    int intOp=QString(data.mid(4,1)).data()->unicode();

    if(intOp==2){
        qDebug() << "*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2";
        qDebug() << "<-*2 SEND Server's public key";
        printf("+--------------------+-------------+----------------------------------+\n");
        printf("| data size (4 byte) | op (1 byte) |    payload (server public key)   |\n");
        printf("+--------------------+-------------+----------------------------------+\n");

        printDataDetail(data);
        qDebug() << "\n\n\n\n\n";
    }
    else if(intOp==4){
        qDebug() << "*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4*4";
        qDebug() << "<-*4 SEND Sign up result";
        printf("+--------------------+-------------+----------------------------------+\n");
        printf("| data size (4 byte) | op (1 byte) |    encrypted(result message)     |\n");
        printf("+--------------------+-------------+----------------------------------+\n");

        printDataDetail(data);
        qDebug() << "\n\n\n\n\n";
    }




}

void MyThread::readyRead(){
    qDebug() << "\nNew data arrived!";

    QByteArray data = socket->readAll();

    unsigned int dataSize;
    QDataStream ds(data.mid(0,4));
    ds >> dataSize;

    unsigned int sizeOfPayloadAndOp=data.mid(4).size();

    if(sizeOfPayloadAndOp==dataSize){
       qDebug() <<"(data SIZE == PAYLOAD + OP) -> NO LOSS!";
       dataFilter(data);
    }


}

void MyThread::disconnected(){

    qDebug() << socketDescriptor << " Disconnected: ";

    socket->deleteLater();
    exit(0);
}
